# Multiple Repositories

The multi-repository support is a huge feature and required a lot of efforts which deserve some enlightenment.

For this test, let's keep the configuration simple and build pgBackRest using the `dev-multi-repo` branch:

```bash
$ cat /etc/pgbackrest.conf 
[global]
# repo details
repo1-path=/var/lib/pgbackrest/repo1
repo1-retention-full=1
repo2-path=/var/lib/pgbackrest/repo2
repo2-retention-full=1

# general options
process-max=2
log-level-console=info
log-level-file=detail
start-fast=y
delta=y

[my_stanza]
pg1-path=/var/lib/pgsql/13/data

$ date
Wed 24 Feb 08:37:49 CET 2021

$ pgbackrest version
pgBackRest 2.33dev
```

We'll follow our usual structure. First initialize the repository then take backups and restore the data.

> **_NOTE:_** that the `repo` option is not required when only `repo1` is configured in order to maintain backward compatibility. However, the `repo` option **is** required when a single repository is configured as, e.g. `repo2`. This is to prevent command breakage if a new repository is added later.

---

## Initialization

### Stanza Create Command

Some commands, e.g. `stanza-create`/`stanza-update`, will automatically work with all configured repositories while others, e.g. `stanza-delete`, will require a repository to be specified using the `repo` option.

> **_NOTE:_** for safety reasons, the `repo` option can't be defined in the configuration file or you'll get a warning: `WARN: configuration file contains command-line only option 'repo'`

```bash
$ pgbackrest --stanza=my_stanza stanza-create
P00   INFO: stanza-create command begin 2.33dev: ...
P00   INFO: stanza-create for stanza 'my_stanza' on repo1
P00   INFO: stanza-create for stanza 'my_stanza' on repo2
P00   INFO: stanza-create command end: completed successfully
```

### Stanza Upgrade Command

```bash
$ pgbackrest --stanza=my_stanza stanza-upgrade
P00   INFO: stanza-upgrade command begin 2.33dev: ...
P00   INFO: stanza-upgrade for stanza 'my_stanza' on repo1
P00   INFO: stanza 'my_stanza' on repo1 is already up to date
P00   INFO: stanza-upgrade for stanza 'my_stanza' on repo2
P00   INFO: stanza 'my_stanza' on repo2 is already up to date
P00   INFO: stanza-upgrade command end: completed successfully
```

### Stanza Delete Command

A stanza may only be deleted from one repository at a time. To delete the stanza from multiple repositories, repeat the `stanza-delete` command for each repository while specifying the `repo` option.

```bash
$ pgbackrest --stanza=my_stanza stop
...

$ pgbackrest --stanza=my_stanza stanza-delete
P00   INFO: stanza-delete command begin 2.33dev: ...
ERROR: [037]: stanza-delete command requires option: repo
       HINT: this command requires a specific repository to operate on
P00   INFO: stanza-delete command end: aborted with exception [037]

$ pgbackrest --stanza=my_stanza stanza-delete --repo=1
P00   INFO: stanza-delete command begin 2.33dev: ...
ERROR: [038]: postmaster.pid exists - looks like PostgreSQL is running. To delete stanza 'my_stanza' on repo1, shut down PostgreSQL for stanza 'my_stanza' and try again, or use --force.
P00   INFO: stanza-delete command end: aborted with exception [038]

$ pgbackrest --stanza=my_stanza stanza-delete --repo=1 --force
P00   INFO: stanza-delete command begin 2.33dev: ...
P00   INFO: stanza-delete command end: completed successfully
```

The [`stanza-delete`](https://github.com/pgbackrest/pgbackrest/blob/dev-multi-repo/src/command/stanza/delete.c#L121) command will remove the stop file generated by the `stop` command. We then need to execute the `stop` command again or re-create the stanza immediately:

```bash
$ pgbackrest --stanza=my_stanza stanza-create --repo=1
ERROR: [031]: option 'repo' not valid for command 'stanza-create'

$ pgbackrest --stanza=my_stanza stanza-create 
P00   INFO: stanza-create command begin 2.33dev: ...
P00   INFO: stanza-create for stanza 'my_stanza' on repo1
P00   INFO: stanza-create for stanza 'my_stanza' on repo2
P00   INFO: stanza 'my_stanza' already exists on repo2 and is valid
P00   INFO: stanza-create command end: completed successfully
```

### Check Command

```bash
$ pgbackrest --stanza=my_stanza check
P00   INFO: check command begin 2.33dev: ...
P00   INFO: check repo1 configuration (primary)
P00   INFO: check repo2 configuration (primary)
P00   INFO: check repo1 archive for WAL (primary)
P00   INFO: WAL segment 000000010000000000000006 successfully archived to '...' on repo1
P00   INFO: check repo2 archive for WAL (primary)
P00   INFO: WAL segment 000000010000000000000006 successfully archived to '...' on repo2
P00   INFO: check command end: completed successfully
```

---

## Backups

### Archive Push Command

The `archive-push` command will always archive WALs in all configured repositories but backups will need to be scheduled individually for each repository. In many cases this is desirable since backup types and retention will vary by repository. 

We can still setup our `archive_command` as usual:

```bash
$ psql -c "show archive_command;"
                archive_command                
-----------------------------------------------
 pgbackrest --stanza=my_stanza archive-push %p
(1 row)
```

Here's a `DEBUG` extract of the PG logs showing the `archive-push` activity:

```
...
P00  DEBUG:     storage/storage::storageNewWrite: => {
	type: posix, name: {"/var/lib/pgbackrest/repo1/archive/my_stanza/13-1/0000000100000000/
							000000010000000000000009-17a2471fc0b8e06f64283cdadb904b276b701ae4.gz"}, 
	modeFile: 0640, modePath: 0750, createPath: true, syncFile: true, syncPath: true, atomic: true}
...
P00  DEBUG:     storage/storage::storageNewWrite: => {
	type: posix, name: {"/var/lib/pgbackrest/repo2/archive/my_stanza/13-1/0000000100000000/
							000000010000000000000009-17a2471fc0b8e06f64283cdadb904b276b701ae4.gz"},
	modeFile: 0640, modePath: 0750, createPath: true, syncFile: true, syncPath: true, atomic: true}
P00   INFO: pushed WAL file '000000010000000000000009' to the archive
```

### Backup Command

Let's take some backups:

```bash
$ pgbackrest backup --stanza=my_stanza --type=full --repo=1
P00   INFO: backup command begin 2.33dev: ..
P00   INFO: execute non-exclusive pg_start_backup(): backup begins after the requested immediate checkpoint completes
P00   INFO: backup start archive = 00000001000000000000000B, lsn = 0/B000028
P00   INFO: full backup size = 23.1MB
P00   INFO: execute non-exclusive pg_stop_backup() and wait for all WAL segments to archive
P00   INFO: backup stop archive = 00000001000000000000000B, lsn = 0/B000100
P00   INFO: check archive for segment(s) 00000001000000000000000B:00000001000000000000000B
P00   INFO: new backup label = 20210224-150437F
P00   INFO: backup command end: completed successfully
P00   INFO: expire command begin 2.33dev: ...
P00   INFO: expire command end: completed successfully

$ pgbackrest backup --stanza=my_stanza --type=full --repo=2
P00   INFO: backup command begin 2.33dev: ...
P00   INFO: execute non-exclusive pg_start_backup(): backup begins after the requested immediate checkpoint completes
P00   INFO: backup start archive = 00000001000000000000000D, lsn = 0/D000028
P00   INFO: full backup size = 23.1MB
P00   INFO: execute non-exclusive pg_stop_backup() and wait for all WAL segments to archive
P00   INFO: backup stop archive = 00000001000000000000000D, lsn = 0/D000100
P00   INFO: check archive for segment(s) 00000001000000000000000D:00000001000000000000000D
P00   INFO: new backup label = 20210224-150449F
P00   INFO: backup command end: completed successfully
P00   INFO: expire command begin 2.33dev: ...
P00   INFO: expire command end: completed successfully

$ pgbackrest backup --stanza=my_stanza --type=incr --repo=1
P00   INFO: backup command begin 2.33dev: ...
P00   INFO: last backup label = 20210224-150437F, version = 2.33dev
P00   INFO: execute non-exclusive pg_start_backup(): backup begins after the requested immediate checkpoint completes
P00   INFO: backup start archive = 00000001000000000000000E, lsn = 0/E000028
P00   INFO: incr backup size = 23.1MB
P00   INFO: execute non-exclusive pg_stop_backup() and wait for all WAL segments to archive
P00   INFO: backup stop archive = 00000001000000000000000E, lsn = 0/E000100
P00   INFO: check archive for segment(s) 00000001000000000000000E:00000001000000000000000E
P00   INFO: new backup label = 20210224-150437F_20210224-150505I
P00   INFO: backup command end: completed successfully
P00   INFO: expire command begin 2.33dev: ...
P00   INFO: expire command end: completed successfully

$ pgbackrest backup --stanza=my_stanza --type=incr --repo=2
P00   INFO: backup command begin 2.33dev: ...
P00   INFO: last backup label = 20210224-150449F, version = 2.33dev
P00   INFO: execute non-exclusive pg_start_backup(): backup begins after the requested immediate checkpoint completes
P00   INFO: backup start archive = 000000010000000000000010, lsn = 0/10000028
P00   INFO: incr backup size = 23.1MB
P00   INFO: execute non-exclusive pg_stop_backup() and wait for all WAL segments to archive
P00   INFO: backup stop archive = 000000010000000000000010, lsn = 0/10000100
P00   INFO: check archive for segment(s) 000000010000000000000010:000000010000000000000010
P00   INFO: new backup label = 20210224-150449F_20210224-150511I
P00   INFO: backup command end: completed successfully
P00   INFO: expire command begin 2.33dev: ...
P00   INFO: expire command end: completed successfully
```

Here, we alternated `full` and `incr` backups in each repository.

### Info Command

```bash
$ pgbackrest info --stanza=my_stanza
stanza: my_stanza
    status: ok
    cipher: none

    db (current)
        wal archive min/max (13): 000000010000000000000006/000000010000000000000010

        full backup: 20210224-150437F
            timestamp start/stop: 2021-02-24 15:04:37 / 2021-02-24 15:04:40
            wal start/stop: 00000001000000000000000B / 00000001000000000000000B
            database size: 23.1MB, database backup size: 23.1MB
            repo1: backup set size: 2.8MB, backup size: 2.8MB

        full backup: 20210224-150449F
            timestamp start/stop: 2021-02-24 15:04:49 / 2021-02-24 15:04:52
            wal start/stop: 00000001000000000000000D / 00000001000000000000000D
            database size: 23.1MB, database backup size: 23.1MB
            repo2: backup set size: 2.8MB, backup size: 2.8MB

        incr backup: 20210224-150437F_20210224-150505I
            timestamp start/stop: 2021-02-24 15:05:05 / 2021-02-24 15:05:06
            wal start/stop: 00000001000000000000000E / 00000001000000000000000E
            database size: 23.1MB, database backup size: 50.7KB
            repo1: backup set size: 2.8MB, backup size: 4.3KB
            backup reference list: 20210224-150437F

        incr backup: 20210224-150449F_20210224-150511I
            timestamp start/stop: 2021-02-24 15:05:11 / 2021-02-24 15:05:12
            wal start/stop: 000000010000000000000010 / 000000010000000000000010
            database size: 23.1MB, database backup size: 52.2KB
            repo2: backup set size: 2.8MB, backup size: 4.4KB
            backup reference list: 20210224-150449F
```

The default order will sort backups by dates mixing the repositories. That might be confusing to find the backups depending on each other.

We can then split this view per repository:

```bash
$ pgbackrest info --stanza=my_stanza --repo=1
stanza: my_stanza
    status: ok
    cipher: none

    db (current)
        wal archive min/max (13): 00000001000000000000000B/000000010000000000000010

        full backup: 20210224-150437F
            timestamp start/stop: 2021-02-24 15:04:37 / 2021-02-24 15:04:40
            wal start/stop: 00000001000000000000000B / 00000001000000000000000B
            database size: 23.1MB, database backup size: 23.1MB
            repo1: backup set size: 2.8MB, backup size: 2.8MB

        incr backup: 20210224-150437F_20210224-150505I
            timestamp start/stop: 2021-02-24 15:05:05 / 2021-02-24 15:05:06
            wal start/stop: 00000001000000000000000E / 00000001000000000000000E
            database size: 23.1MB, database backup size: 50.7KB
            repo1: backup set size: 2.8MB, backup size: 4.3KB
            backup reference list: 20210224-150437F

$ pgbackrest info --stanza=my_stanza --repo=2
stanza: my_stanza
    status: ok
    cipher: none

    db (current)
        wal archive min/max (13): 000000010000000000000006/000000010000000000000010

        full backup: 20210224-150449F
            timestamp start/stop: 2021-02-24 15:04:49 / 2021-02-24 15:04:52
            wal start/stop: 00000001000000000000000D / 00000001000000000000000D
            database size: 23.1MB, database backup size: 23.1MB
            repo2: backup set size: 2.8MB, backup size: 2.8MB

        incr backup: 20210224-150449F_20210224-150511I
            timestamp start/stop: 2021-02-24 15:05:11 / 2021-02-24 15:05:12
            wal start/stop: 000000010000000000000010 / 000000010000000000000010
            database size: 23.1MB, database backup size: 52.2KB
            repo2: backup set size: 2.8MB, backup size: 4.4KB
            backup reference list: 20210224-150449F
```

The **'wal archive min/max'** shows the minimum and maximum WAL currently stored in the archive and, in the case of multiple repositories, will be reported across all repositories unless the `--repo` option is set. Note that there may be gaps due to archive retention policies or other reasons.

Let's break our first repository by removing its content:

```bash
$ pgbackrest --stanza=my_stanza stop
P00   INFO: stop command end: completed successfully

$ pgbackrest --stanza=my_stanza stanza-delete --repo=1 --force
P00   INFO: stanza-delete command end: completed successfully

$ pgbackrest --stanza=my_stanza stanza-create
P00   INFO: stanza-create for stanza 'my_stanza' on repo1
P00   INFO: stanza-create for stanza 'my_stanza' on repo2
P00   INFO: stanza 'my_stanza' already exists on repo2 and is valid
P00   INFO: stanza-create command end: completed successfully
```

If there are multiple repositories, then a status of **'mixed'** indicates that the stanza is not in a healthy state on one or more of the repositories. In this case the state of the stanza will be detailed on additional lines per repository. 

```bash
$ pgbackrest info --stanza=my_stanza
stanza: my_stanza
    status: mixed
        repo1: error (no valid backups)
        repo2: ok
    cipher: none

    db (current)
        wal archive min/max (13): 000000010000000000000006/000000010000000000000010

        full backup: 20210224-150449F
            timestamp start/stop: 2021-02-24 15:04:49 / 2021-02-24 15:04:52
            wal start/stop: 00000001000000000000000D / 00000001000000000000000D
            database size: 23.1MB, database backup size: 23.1MB
            repo2: backup set size: 2.8MB, backup size: 2.8MB

        incr backup: 20210224-150449F_20210224-150511I
            timestamp start/stop: 2021-02-24 15:05:11 / 2021-02-24 15:05:12
            wal start/stop: 000000010000000000000010 / 000000010000000000000010
            database size: 23.1MB, database backup size: 52.2KB
            repo2: backup set size: 2.8MB, backup size: 4.4KB
            backup reference list: 20210224-150449F

```

Fix it by taking a new backup:

```bash
$ pgbackrest backup --stanza=my_stanza --type=full --repo=1
P00   INFO: backup command begin 2.33dev: ...
P00   INFO: execute non-exclusive pg_start_backup(): backup begins after the requested immediate checkpoint completes
P00   INFO: backup start archive = 000000010000000000000012, lsn = 0/12000028
P00   INFO: full backup size = 23.1MB
P00   INFO: execute non-exclusive pg_stop_backup() and wait for all WAL segments to archive
P00   INFO: backup stop archive = 000000010000000000000012, lsn = 0/12000138
P00   INFO: check archive for segment(s) 000000010000000000000012:000000010000000000000012
P00   INFO: new backup label = 20210224-152813F
P00   INFO: backup command end: completed successfully
P00   INFO: expire command begin 2.33dev: ...
P00   INFO: expire command end: completed successfully
```

### Expire Command

In fact, the impact on the `expire` command is pretty simple: it can run with or without specifying the `repo` option.

> Tip: taking some backups using the `--no-expire-auto` option allows to look at how the `expire` command works afterwards.

```bash
$ pgbackrest expire --stanza=my_stanza --set=20210224-153348F
P00   INFO: expire command begin 2.33dev: ...
P00   INFO: repo1: expire adhoc backup 20210224-153348F
P00   INFO: repo1: remove expired backup 20210224-153348F
P00   INFO: expire command end: completed successfully

$ pgbackrest expire --stanza=my_stanza
P00   INFO: expire command begin 2.33dev: ...
P00   INFO: repo1: expire full backup 20210224-165110F
P00   INFO: repo1: remove expired backup 20210224-165110F
P00   INFO: repo2: expire full backup set 20210224-150449F, 20210224-150449F_20210224-150511I
P00   INFO: repo2: remove expired backup 20210224-150449F_20210224-150511I
P00   INFO: repo2: remove expired backup 20210224-150449F
P00   INFO: expire command end: completed successfully
```

---

## Restore

Let's initiate a nice situation with some data, backups and restore point:

```bash
$ createdb test
$ psql -d test -c "CREATE TABLE t1(id int);"
CREATE TABLE
$ psql -d test -c "INSERT INTO t1 VALUES (1);"
INSERT 0 1

$ pgbackrest backup --stanza=my_stanza --type=full --repo=1
P00   INFO: backup command begin 2.33dev: ...
P00   INFO: execute non-exclusive pg_start_backup(): backup begins after the requested immediate checkpoint completes
P00   INFO: backup start archive = 00000001000000000000001E, lsn = 0/1E000028
P00   INFO: full backup size = 30.7MB
P00   INFO: execute non-exclusive pg_stop_backup() and wait for all WAL segments to archive
P00   INFO: backup stop archive = 00000001000000000000001E, lsn = 0/1E000100
P00   INFO: check archive for segment(s) 00000001000000000000001E:00000001000000000000001E
P00   INFO: new backup label = 20210224-171455F
P00   INFO: backup command end: completed successfully

$ psql -d test -c "INSERT INTO t1 VALUES (2);"
INSERT 0 1
$ pgbackrest backup --stanza=my_stanza --type=full --repo=2
P00   INFO: backup command begin 2.33dev: ...
P00   INFO: execute non-exclusive pg_start_backup(): backup begins after the requested immediate checkpoint completes
P00   INFO: backup start archive = 000000010000000000000020, lsn = 0/20000028
P00   INFO: full backup size = 30.7MB
P00   INFO: execute non-exclusive pg_stop_backup() and wait for all WAL segments to archive
P00   INFO: backup stop archive = 000000010000000000000020, lsn = 0/20000100
P00   INFO: check archive for segment(s) 000000010000000000000020:000000010000000000000020
P00   INFO: new backup label = 20210224-171512F
P00   INFO: backup command end: completed successfully

$ psql -c "select pg_create_restore_point('RP1');"
 pg_create_restore_point 
-------------------------
 0/A01A598
(1 row)

$ psql -Atc "select current_timestamp,current_setting('datestyle'),txid_current();"
2021-02-24 17:19:19.55914+01|ISO, MDY|491

$ psql -d test -c "INSERT INTO t1 VALUES (3); SELECT pg_switch_wal();"
 pg_switch_wal 
---------------
 0/21000138
(1 row)

$ pgbackrest info --stanza=my_stanza
stanza: my_stanza
    status: ok
    cipher: none

    db (current)
        wal archive min/max (13): 00000001000000000000001E/000000010000000000000021

        full backup: 20210224-171455F
            timestamp start/stop: 2021-02-24 17:14:55 / 2021-02-24 17:14:59
            wal start/stop: 00000001000000000000001E / 00000001000000000000001E
            database size: 30.7MB, database backup size: 30.7MB
            repo1: backup set size: 3.8MB, backup size: 3.8MB

        full backup: 20210224-171512F
            timestamp start/stop: 2021-02-24 17:15:12 / 2021-02-24 17:15:16
            wal start/stop: 000000010000000000000020 / 000000010000000000000020
            database size: 30.7MB, database backup size: 30.7MB
            repo2: backup set size: 3.8MB, backup size: 3.8MB
```

### Restore Command

The restore command automatically defaults to selecting the latest backup from the first repository where backups exist. The order in which the repositories are checked is dictated by the `pgbackrest.conf` (e.g. repo1 will be checked before repo2). To select from a specific repository, the `--repo` option can be passed.

For PITR, `--type=time` must be provided and the target time specified with the `--target` option. If a backup is not specified via the `--set` option, then the configured repositories will be checked, in order, for a backup that contains the requested time. If no backup can be found, the latest backup from the first repository containing backups will be used.

```bash
$ mkdir /tmp/restored_data
$ pgbackrest restore --stanza=my_stanza --target="RP1" --type=name --no-delta --pg1-path=/tmp/restored_data
P00   INFO: repo1: restore backup set 20210224-171455F

$ rm -rf /tmp/restored_data/*
$ pgbackrest restore --stanza=my_stanza --target="2021-02-24 17:19:19.55914+01" --type=time --no-delta --pg1-path=/tmp/restored_data
P00   INFO: repo1: restore backup set 20210224-171455F

$ rm -rf /tmp/restored_data/* 
$ pgbackrest restore --stanza=my_stanza --target="RP1" --type=name --no-delta --pg1-path=/tmp/restored_data --repo=2
P00   INFO: repo2: restore backup set 20210224-171512F
```

Even if the backup in **repo2** is newer, the first match found for our time target is kept. Let's take a new backup in **repo1** to check if pgBackRest will auto-select the backup in **repo2**:

```bash
$ pgbackrest backup --stanza=my_stanza --type=full --repo=1
P00   INFO: backup command begin 2.33dev: ...
P00   INFO: execute non-exclusive pg_start_backup(): backup begins after the requested immediate checkpoint completes
P00   INFO: backup start archive = 000000010000000000000024, lsn = 0/24000028
P00   INFO: full backup size = 30.7MB
P00   INFO: execute non-exclusive pg_stop_backup() and wait for all WAL segments to archive
P00   INFO: backup stop archive = 000000010000000000000024, lsn = 0/24000100
P00   INFO: check archive for segment(s) 000000010000000000000024:000000010000000000000024
P00   INFO: new backup label = 20210224-172601F
P00   INFO: backup command end: completed successfully
P00   INFO: expire command begin 2.33dev: ...
P00   INFO: repo1: expire full backup 20210224-171455F
P00   INFO: repo1: remove expired backup 20210224-171455F
P00   INFO: expire command end: completed successfully

$ pgbackrest info --stanza=my_stanza
stanza: my_stanza
    status: ok
    cipher: none

    db (current)
        wal archive min/max (13): 000000010000000000000020/000000010000000000000024

        full backup: 20210224-171512F
            timestamp start/stop: 2021-02-24 17:15:12 / 2021-02-24 17:15:16
            wal start/stop: 000000010000000000000020 / 000000010000000000000020
            database size: 30.7MB, database backup size: 30.7MB
            repo2: backup set size: 3.8MB, backup size: 3.8MB

        full backup: 20210224-172601F
            timestamp start/stop: 2021-02-24 17:26:01 / 2021-02-24 17:26:05
            wal start/stop: 000000010000000000000024 / 000000010000000000000024
            database size: 30.7MB, database backup size: 30.7MB
            repo1: backup set size: 3.8MB, backup size: 3.8MB

$ rm -rf /tmp/restored_data/*
$ pgbackrest restore --stanza=my_stanza --target="2021-02-24 17:19:19.55914" --type=time --no-delta --pg1-path=/tmp/restored_data
P00   INFO: repo2: restore backup set 20210224-171512F
```

The recovery process might be touchy and the `info` command will really be helpful for you to chose from which repository the restored data should come from.

### Archive Get Command

When multiple repositories are configured, WAL will be fetched from the repositories in priority order (e.g. `repo1`, `repo2`, etc.). In general it is better if faster/cheaper storage has higher priority. If a repository is specified with the `--repo` option then only that repository will be searched.

```bash
root# systemctl stop postgresql-13
$ mv /var/lib/pgsql/13/data /var/lib/pgsql/13/data.orig
$ mkdir -m 700 /var/lib/pgsql/13/data

$ pgbackrest restore --stanza=my_stanza --target="2021-02-24 17:19:19.55914" --type=time --no-delta
P00   INFO: restore command begin 2.33dev: ...
P00   INFO: repo2: restore backup set 20210224-171512F
P00   INFO: write updated /var/lib/pgsql/13/data/postgresql.auto.conf
P00   INFO: restore global/pg_control (performed last to ensure aborted restores cannot be started)
P00   INFO: restore command end: completed successfully

$ cat /var/lib/pgsql/13/data/postgresql.auto.conf|grep restore_command
restore_command = 'pgbackrest --stanza=my_stanza archive-get %f "%p"'

root# systemctl start postgresql-13
$ cat /var/lib/pgsql/13/data/log/postgresql-*.log
...
LOG:  starting point-in-time recovery to 2021-02-24 17:19:19.55914+01
P00   INFO: found 000000010000000000000020 in the repo2: 13-1 archive
P00   INFO: found 000000010000000000000021 in the repo2: 13-1 archive
P00   INFO: found 000000010000000000000022 in the repo2: 13-1 archive
LOG:  recovery stopping before commit of transaction 491, time 2021-02-24 17:19:19.561041+01
LOG:  redo done at 0/22000128
LOG:  last completed transaction was at log time 2021-02-24 17:15:31.438799+01
P00   INFO: unable to find 00000002.history in the archive
LOG:  selected new timeline ID: 2
LOG:  archive recovery complete
P00   INFO: unable to find 00000001.history in the archive
P00   INFO: pushed WAL file '00000002.history' to the archive

$ ls /var/lib/pgbackrest/repo*/archive/my_stanza/13-1/00000002.history 
/var/lib/pgbackrest/repo1/archive/my_stanza/13-1/00000002.history
/var/lib/pgbackrest/repo2/archive/my_stanza/13-1/00000002.history
```

PG found the WALs needed for recovery in our **repo2**, picked a new timeline and pushed the history file to the repositories. 

```bash
root# systemctl stop postgresql-13
$ rm -rf /var/lib/pgsql/13/data/*
$ rm -rf /var/lib/pgbackrest/repo1/archive/my_stanza/13-1/00000002.history
$ pgbackrest restore --stanza=my_stanza --target="2021-02-24 17:19:19.55914" --type=time --target-timeline=current --no-delta
P00   INFO: restore command begin 2.33dev: ...
P00   INFO: repo2: restore backup set 20210224-171512F
P00   INFO: write updated /var/lib/pgsql/13/data/postgresql.auto.conf
P00   INFO: restore global/pg_control (performed last to ensure aborted restores cannot be started)
P00   INFO: restore command end: completed successfully

root# systemctl start postgresql-13
$ cat /var/lib/pgsql/13/data/log/postgresql-*.log
P00   INFO: found 00000002.history in the repo2: 13-1 archive
P00   INFO: unable to find 00000003.history in the archive
LOG:  selected new timeline ID: 3
P00   INFO: pushed WAL file '00000003.history' to the archive
```

Let's retry it by moving the history file in **repo1** now.

```bash
root# systemctl stop postgresql-13
$ rm -rf /var/lib/pgsql/13/data/*
$ mv /var/lib/pgbackrest/repo2/archive/my_stanza/13-1/00000002.history /var/lib/pgbackrest/repo1/archive/my_stanza/13-1/00000002.history
$ pgbackrest restore --stanza=my_stanza --target="2021-02-24 17:19:19.55914" --type=time --target-timeline=current --no-delta
root# systemctl start postgresql-13
$ cat /var/lib/pgsql/13/data/log/postgresql-*.log
P00   INFO: found 00000002.history in the repo1: 13-1 archive
P00   INFO: found 00000003.history in the repo1: 13-1 archive
P00   INFO: unable to find 00000004.history in the archive
LOG:  selected new timeline ID: 4
P00   INFO: pushed WAL file '00000004.history' to the archive
```

As we can see above, both `00000002.history` and `00000003.history` have been found in **repo1** so PG could pick the next timeline correctly.

The `archive-get` enhancement really seems promising mainly because we could have gaps in one repository (due to lack of disk space e.g.) but it would still be able to find it in the other repository.

---

## Conclusion

This new multi-repository feature will open a new world of possibilities regarding redundancy or retention policies and much more...